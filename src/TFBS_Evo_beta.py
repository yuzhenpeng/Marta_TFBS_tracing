#!/home/yangz6/Software/Python-2.7.5/python
# Programmer : zocean
# Date: 
# Last-modified: 09 Aug 2017 10:24:02

import os,sys,argparse
import numpy as np
from math import log10,exp,ceil
from multiprocessing import Pool
import random
from ete2 import Tree
from time import clock
from bx.bbi.bigwig_file import BigWigFile
from TFBS_Evo.math_fun import * 
from TFBS_Evo.my_utility import ReadFromFile,WriteToFile
from TFBS_Evo.parameter_default import alpha_init, beta_init, Human_Mouse_Time, Human_Mouse_Branch, Human_Mouse_Branch_Ken
from TFBS_Evo.maf_utility import MafFile

def ParseArg():
    ''' This Function Parse the Argument '''
    p=argparse.ArgumentParser( description = 'Example: %(prog)s -h', epilog='Library dependency :')
    p.add_argument('-v','--version',action='version',version='%(prog)s beta.20150615')
    p.add_argument('--fast',type=int,dest="fast",default=10,help="fast version, recommend range is between 5 to 25, default is 10")
    p.add_argument('--np',type=int,dest="thread",help="number of thread used")
    p.add_argument('-c','--count',type=str,dest="count",help="tfbs count file, generated by tfbs_scan_in_peak.py")
    p.add_argument('--nopos',dest="nopos",action="store_true",help="the first column of tfbs count file does not contain position information, if this argument is set, '--outorder' and '--phyloP' will be ignored")
    p.add_argument('-s','--species',type=str,dest="spe",help="target species")
    p.add_argument('-t','--tree',type=str,dest="tree",help="phylogenetic tree file")
    p.add_argument('-n','--name',type=str,dest="branchname",help="branch name for internal node. Format: <spe1>\t<spe2>\t<last common ancestor name>")
    p.add_argument('--branchtime',type=str,dest="branchtime",default="simple",help="method to scale branch length to time, default is 'simple' which means the scale the branch length based on human-mouse divergent time, other choice is 'matchken', which use the setting in previous paper, for other reference species, use 'user' and specifity --branchtime_ratio")
    p.add_argument('--branchtime_ratio',type=float,dest="branchtime_ratio",help="ratio between evolution time and branch length")
    p.add_argument('--assumeyoung',dest="assumeyoung",action="store_true",help="use assumeyoung mode to predict the age of TFBS")
    p.add_argument('-w','--win',type=int,dest="win",help="window size used to count motif")
    p.add_argument('-o','--output',type=str,dest="output",help="output file name")
    p.add_argument('--outorder',type=str,dest="outorder",default="simple",help="method to assign branch to tfbs, 'phyloP' means use the phyloP score to order the binding sites, 'maf' means use maf to order the binding sites based on sequence identity percent, 'simple' means order them by their name in python dictionary, default is 'simple'")
    p.add_argument('--phyloP',type=str,dest="phyloP",help="phyloP bigwig file")
    p.add_argument('--maf',type=str,dest="maf",help="maf file folder")
    if len(sys.argv) < 2:
        print p.print_help()
        exit(1)
    return p.parse_args()

###################
# Load motif count
###################

def CheckHeader(spe_header,tree):
    """Check the header of count file with input phylogenetic tree. Construct the count dict"""
    leaves = [node.name for node in tree.get_leaves()]
    if len(spe_header) != len(leaves) and len(spe_header) != len(leaves) + 1:
        error("leave species number not equal to leaves number in the tree")
        exit(1)
    spe_name = []
    for spe in spe_header:
        if spe == "pos":
            continue
        if spe not in leaves:
            error("species name %s cannot find in tree" % (spe))
            exit(1)
        else:
            spe_name.append(spe)
    return spe_name

def LoadCount(filename,tree):
    """Load motif count into a list, each element is a phylogenetic tree structure (update)"""
    num = 1
    count_list = []
    last = None
    for line in ReadFromFile(filename):
        if line.strip().startswith('#') or line.strip() == '':
            continue
        # for duplicate rows, skip it
        if last is None:
            last = line.strip()
        else:
            if last == line.strip():
                continue
            last = line.strip()
        # 
        row = line.strip().split('\t')
        if num == 1:
            spe_name = CheckHeader(row,tree)
        else:
            table = {}
            table['pos'] = [pos for pos in row[0].split(',')]
            if len(table['pos']) < 1 or len(row) < len(spe_name):
                continue
            count = {}
            for nn in range(len(row))[1:]:
                count[spe_name[nn-1]] = int(row[nn])
            table['count'] = count
            count_list.append(table)
        num += 1
    return count_list

############
# Load Tree
############

def Tree_add_id(tree):
    """ add id to each node in the tree"""
    num = 0
    for node in tree.traverse("postorder"):
        node.add_features(id = num)
        num += 1
    logging("Process: Reading tree DONE. %d nodes in total" % (num))

def Tree_add_prob(tree):
    """ add prob. sign to each node in the tree"""
    for node in tree.traverse("postorder"):
        node.add_features(prob = False)

def Tree_add_branch_name(tree,branch_filename):
    """ add internal branch name in the tree, if not set will use the id as name"""
    internal = {}
    for line in ReadFromFile(branch_filename):
        if line.strip().startswith('#') or line.strip() == '':
            continue
        row = line.strip().split()
        branch_a = row[0]
        branch_b = row[1]
        name = row[2]
        internal[(branch_a,branch_b)] = name
    for key in internal.keys():
        node = tree.get_common_ancestor([key[0],key[1]])
        node.name = internal[key]
    for node in tree.traverse("postorder"):
        if node.name == "NoName":
            node.name = "Node_%d" % (node.id)
    logging("Process: Add internal branch name DONE!")

def Tree_add_branch_time(tree,mode,ratio=None):
    """add branch time in the tree"""
    if mode == 'simple':
        for node in tree.traverse("postorder"):
            node.add_features(time = node.dist*Human_Mouse_Time/Human_Mouse_Branch) 
    elif mode == 'matchken': # implement method to set branch length (time) same as Ken's setting
        for node in tree.traverse("postorder"):
            if node.name == 'Human-Chimp':
                node.add_features(time = node.dist*1.7*Human_Mouse_Time/Human_Mouse_Branch_Ken) # 1.7 is an arbitary ratio
            else:
                node.add_features(time = node.dist*Human_Mouse_Time/Human_Mouse_Branch_Ken)
    elif mode == 'user':
        for node in tree.traverse("postorder"):
            node.add_features(time = node.dist*ratio)
    else:
        error("Unknown branchtime method %s" % (mode))
    logging("Process: Add branch time DONE!")

def Tree_get_total_time(tree):
    """return the total branch time"""
    total_time = 0.0
    for node in tree.traverse("postorder"):
        total_time += node.time
    return total_time

def LoadTree(tree_filename,branch_filename,branchtime,ratio=None):
    """Load phylogenetic tree file (newick format), do initialization on tree"""
    t = Tree(tree_filename)
    # add id
    Tree_add_id(t)
    # add prob
    Tree_add_prob(t)
    # add internal node name
    if branch_filename is not None:
        Tree_add_branch_name(t,branch_filename)
    # add time
    Tree_add_branch_time(t,branchtime,ratio)
    name2id = {}
    for node in t.traverse("postorder"):
        name2id[node.name] = node.id
    return t

##########################
# Find maximum likelihood
##########################

def BOO(count_list,tree,spe,init_alpha,init_beta,win,iter_num):
    """The main function of BOO"""
    alpha = init_alpha
    beta = init_beta
    logging("Process: initial alpha is %e, initial beta is %e" % (init_alpha,init_beta))
    for nn in range(iter_num):
        result_list,new_alpha,new_beta = model_in_all_region(count_list,tree,alpha,beta,win)
        if abs(new_alpha - alpha) < 1e-25 and abs(new_beta - beta) < 1e-25:
            logging("Process: Converge on alpha %e, beta %e" % (new_alpha,new_beta))
            break
        alpha = new_alpha
        beta = new_beta
        logging("Process: Iteration %d: new alpha is %e, new beta is %e" % (nn+1,alpha,beta))
    # retrieve boo_list
    boo_list = []
    spe_node = tree.get_leaves_by_name(spe)[0]
    spe_id = spe_node.id
    for result_table in result_list:
        boo_table = {}
        boo_table['pos'] = result_table['pos']
        boo_table['count'] = {}
        spe_count = result_table['count'][spe_id]
        tfbs_boo_determine(spe_count,spe_node,boo_table['count'],result_table['count'],alpha,beta,win)
        boo_list.append(boo_table)
    #print boo_list
    return boo_list

def BOO_converge(count_list,tree,spe,init_alpha,init_beta,win,iter_num):
    """get initial alpha and beta"""
    alpha = init_alpha
    beta = init_beta
    parameter_list = {'alpha':[],'beta':[]}
    parameter_list['alpha'].append(alpha)
    parameter_list['beta'].append(beta)
    logging("Process: Converge test: initial alpha is %e, initial beta is %e" % (init_alpha,init_beta))
    for nn in range(iter_num):
        result_list,new_alpha,new_beta = model_in_all_region(count_list,tree,alpha,beta,win)
        if abs(new_alpha - alpha) < 1e-25 and abs(new_beta - beta) < 1e-25:
            logging("Process: Converge on alpha %e, beta %e" % (new_alpha,new_beta))
            break
        parameter_list['alpha'].append(new_alpha)
        parameter_list['beta'].append(new_beta)
        alpha = new_alpha
        beta = new_beta
        logging("Process: Converage test: Iteration %d: new alpha is %e, new beta is %e" % (nn+1,alpha,beta))
    return parameter_list

def tfbs_boo_determine(spe_count,node,boo_table,result_table,alpha,beta,N):
    """get the age of tfbs"""
    if spe_count <= 0:
        return
    if node.is_root():
        boo_table[node.name] = spe_count
        #boo_table['Root'] = spe_count
    else:
        parent = node.up
        parent_ii = result_table[parent.id]
        node_jj = result_table[node.id]
        time_jj = node.time
        prob, bd = trans_prob_best(N,parent_ii,node_jj,time_jj,alpha,beta)
        new_born = bd[0]
        new_death = bd[1]
        net_born = new_born - new_death
        count_change = 0
        if net_born > 0:
            if args.assumeyoung:
                count_change = min(net_born,spe_count)
                boo_table[node.name] = count_change
            else:
                if parent_ii >= spe_count: # if patent still has enough bindign site, we think the tfbs is from parent
                    pass
                else:
                    count_change = min(net_born,spe_count-parent_ii)
                    boo_table[node.name] = count_change
        tfbs_boo_determine(spe_count-count_change,parent,boo_table,result_table,alpha,beta,N)

def model_in_all_region(count_list,tree,alpha,beta,win):
    """run model in all region, with given parameters"""
    birth_list = []
    death_list = []
    birth_bp_list = []
    death_bp_list = []
    result_list = []
    def log_result(result):
        if result is None:
            return
        result_list.append(result[0])
        birth_list.append(result[1][0])
        death_list.append(result[1][1])
        birth_bp_list.append(result[1][2])
        death_bp_list.append(result[1][3])
        if len(result_list) % 1000 == 0:
            logging("Process: %d line done." %(len(result_list)))
    pool = Pool(processes=args.thread)
    for count_table in count_list:
        pool.apply_async(model_in_one_region,[count_table,tree,alpha,beta,win],callback=log_result)
    pool.close()
    pool.join()
    #for count_table in count_list:
    #    result = model_in_one_region(count_table,tree,alpha,beta,win)
    #    log_result(result)
    birth = sum(birth_list)
    death = sum(death_list)
    birth_bp = sum(birth_bp_list)
    death_bp = sum(death_bp_list)
    total_time = Tree_get_total_time(tree)
    new_alpha,new_beta = recal_param(birth,death,birth_bp,death_bp,total_time,win)
    return result_list,new_alpha,new_beta

def model_in_one_region(count_table,tree,alpha,beta,N):
    """run model in one region, with given parameters"""
    eps = args.eps 
    # create calculation matrix
    num_nodes = len(tree.get_descendants()) + 1 # do not forget the root node
    args.nodenum = max(args.fast+1,max(count_table['count'].values())+1)
    T1 = eps*np.ones(shape=(args.nodenum,num_nodes),dtype=np.float64) # store prob.
    T2 = [] # store path
    T3 = [] # store expected birth death count, and un-occupied bp and occupied bp
    tmp_pos = (-1,-1),(-1,-1)
    tmp_bd = (0.0,0.0,0,0)
    for ii in range(args.nodenum):
        tmp_row_T2 = []
        tmp_row_T3 = []
        for jj in range(num_nodes):
            tmp_row_T2.append(tmp_pos)
            tmp_row_T3.append(tmp_bd)
        T2.append(tmp_row_T2)
        T3.append(tmp_row_T3)
    # add prob to leaves
    for name in count_table['count'].keys():
        node = tree.get_leaves_by_name(name)[0]
        T1[(count_table['count'][name],node.id)] = 0.0 
        node.prob = True
    # forward step
    #lam = int(ceil(np.mean(count_table['count'].values())))
    #if lam == 0:
    #    lam = 1
    lam = int(round(np.mean(count_table['count'].values())))
    if model_forward(T1,T2,T3,tree,alpha,beta,N,lam) == 'zero_prob':
        return None
    # reverse step
    result_table = {}
    result_table['pos'] = count_table['pos']
    result_table['count'] = {} 
    root = tree.get_tree_root()
    max_lld = -1000000.0
    #max_lld = 0.0
    max_root = 0
    for ii in range(args.nodenum):
        if T1[ii,root.id] > max_lld:
            max_lld = T1[ii,root.id]
            max_root = ii
    #print max_root, max_lld
    result_table['count'][root.id] = max_root
    model_reverse(T2,(max_root,root.id),result_table['count'])
    # print ancestor
    ancestor = [] 
    for node in tree.traverse("postorder"):
        if node.name != 'NoName':
            ancestor.append((node.name,result_table['count'][node.id]))
    for node in tree.traverse("postorder"):
        node.prob = False
    # get birth/death count
    bd = T3[max_root][root.id]
    return result_table,bd

def model_forward(T1,T2,T3,tree,alpha,beta,N,lam):
    """add prob to internal nodes"""
    min_prob = args.min_prob
    # forward step
    for node in tree.traverse("postorder"):
        if node.is_leaf():
            continue
        elif node.children[0].prob is False or node.children[1].prob is False:
            error("Children prob is False")
            exit(1)
        else: # calculate the best prob
            child_a_id = node.children[0].id
            child_b_id = node.children[1].id
            tt_a = node.children[0].time
            tt_b = node.children[1].time
            for ii in range(args.nodenum):
                max_prob = min_prob 
                max_pos = (None,None)
                max_bd = (0.0,0.0,0,0)
                table_jj_a = {}
                table_jj_b = {}
                for jj_a in range(args.nodenum):
                    table_jj_a[jj_a] = trans_prob(N,ii,jj_a,tt_a,alpha,beta)
                for jj_b in range(args.nodenum):
                    table_jj_b[jj_b] = trans_prob(N,ii,jj_b,tt_b,alpha,beta)
                for jj_a in range(args.nodenum):
                    for jj_b in range(args.nodenum):
                        prob_a,bd_a = table_jj_a[jj_a] 
                        prob_b,bd_b = table_jj_b[jj_b]
                        prob = prob_a + T1[jj_a,child_a_id] + prob_b + T1[jj_b,child_b_id]
                        bd = (bd_a[0]+bd_b[0],bd_a[1]+bd_b[1],2*N-2*ii,2*ii)
                        if max_prob < prob:
                            max_prob = prob
                            max_pos = ((jj_a,child_a_id),(jj_b,child_b_id))
                            max_bd = bd
                if max_pos == (None,None):
                    error("prob is zero?")
                    return "zero_prob"
                    #exit(1)
                T1[ii,node.id] = max_prob
                T2[ii][node.id] = max_pos
                T3[ii][node.id] = (max_bd[0] + T3[max_pos[0][0]][max_pos[0][1]][0] + T3[max_pos[1][0]][max_pos[1][1]][0], max_bd[1] + T3[max_pos[0][0]][max_pos[0][1]][1] + T3[max_pos[1][0]][max_pos[1][1]][1], max_bd[2] + T3[max_pos[0][0]][max_pos[0][1]][2] + T3[max_pos[1][0]][max_pos[1][1]][2], max_bd[3] + T3[max_pos[0][0]][max_pos[0][1]][3] + T3[max_pos[1][0]][max_pos[1][1]][3])
        node.prob = True
    # add prior prob to root
    root = tree.get_tree_root()
    #print lam
    for ii in range(args.nodenum):
        T1[ii,root.id] = T1[ii,root.id] + log10(max(poisson_prob(lam,ii), args.eps_raw))
 
def model_reverse(T2,pos,result_table):
    """get the best path reversively"""
    result_table[pos[1]] = pos[0]
    if T2[pos[0]][pos[1]] != ((-1,-1),(-1,-1)):
        model_reverse(T2,T2[pos[0]][pos[1]][0],result_table)
        model_reverse(T2,T2[pos[0]][pos[1]][1],result_table)

def recal_param(birth,death,birth_bp,death_bp,time,win):
    """re-esitmated alpha and beta"""
    return max(float(birth)/float(time)/float(birth_bp),1e-16),max(float(death)/float(time)/float(death_bp),1e-16)

###################
# Branch Of Origin
###################

def retrieve_boo(boo_list, spe, out_filename, mode, phyloP_filename, maf_folder, tree):
    """retrieve the age of each binding site, main species is spe"""
    out = WriteToFile(out_filename)
    if mode == "phyloP":
        if phyloP_filename is None:
            error("outorder method is phyloP, a bigwig phyloP file must be provided")
            exit(1)
        else:
            phyloP_bw = BigWigFile(open(phyloP_filename))
        node = tree.get_leaves_by_name(spe)[0]
        branch_order = {}
        num = 0
        while not node.is_root():
            branch_order[num] = node.name
            node = node.up
            num += 1
        # add the root
        branch_order[num] = node.name
        branch_order_sorted = sorted(branch_order.keys())
    elif mode == "maf":
        if maf_folder is None:
            error("outrder method is maf, maf file folder must be provided")
            exit(1)
        else:
            maf_block = MafFile(spe, maf_folder)
        node = tree.get_leaves_by_name(spe)[0]
        branch_order = {}
        num = 0
        while not node.is_root():
            branch_order[num] = node.name
            node = node.up
            num += 1
        # add the root
        branch_order[num] = node.name
        branch_order_sorted = sorted(branch_order.keys())
        # get spe_list
        spe_list = [leaf.name for leaf in tree]
    else:
        print >>sys.stderr, "Unknown mode: %s" % (mode)
        exit(1)
    for boo_table in boo_list:
        poslist = boo_table['pos']
        agelist = []
        if len(boo_table['count']) == 0:
            warning("The program think the number of TFBS (eg. %s) in target species is not realistic. Skip it." % (poslist[0]))
            continue
        if mode == "simple":
            for branch in boo_table['count'].keys():
                for nn in range(boo_table['count'][branch]):
                    agelist.append(branch)
        elif mode == "phyloP":
            phyloP_list = []
            total_spe = 0
            for branch in boo_table['count'].keys():
                total_spe += boo_table['count'][branch]
            # in some cases the number of tfbs will not equal to leaf number
            if total_spe != len(poslist):
                warning("The program think the number of TFBS (eg. %s) in target species is not realistic. Sample %d TFBS from total %d TFBS" % (poslist[0],total_spe,len(poslist)))
                poslist = [ poslist[i] for i in sorted(random.sample(xrange(len(poslist)), total_spe)) ]
            for region in poslist:
                region_pos = region.replace(':','-').split('-')
                chrom = region_pos[0]
                start = int(region_pos[1])
                stop = int(region_pos[2])
                array = phyloP_bw.get_as_array(chrom,start,stop)
                invalid = np.isnan(array)
                array[invalid] = 0.0
                phyloP_list.append(sum(array))
            phyloP_index = np.argsort(np.array(phyloP_list))
            phyloP_order = {}
            for nn in range(len(poslist)):
                phyloP_order[phyloP_index[nn]] = nn
            branch_list = {}
            num = 0
            for nn in branch_order_sorted:
                if branch_order[nn] in boo_table['count']:
                    for mm in range(boo_table['count'][branch_order[nn]]):
                        branch_list[num] = branch_order[nn]
                        num += 1
            for nn in range(len(poslist)):
                agelist.append(branch_list[phyloP_order[nn]])
        elif mode == "maf":
            maf_list = []
            total_spe = 0
            for branch in boo_table['count'].keys():
                total_spe += boo_table['count'][branch]
            if total_spe != len(poslist):
                warning("The program think the number of TFBS (eg. %s) in target species is not realistic. Sample %d TFBS from total %d TFBS" % (poslist[0],total_spe,len(poslist)))
                poslist = [ poslist[i] for i in sorted(random.sample(xrange(len(poslist)), total_spe)) ]
            for region in poslist:
                region_pos = region.replace(':','-').split('-')
                chrom = region_pos[0]
                start = int(region_pos[1])
                stop = int(region_pos[2])
                score = maf_block.score(chrom,start,stop, spe, spe_list)
                maf_list.append(score)
            maf_index = np.argsort(np.array(maf_list))
            maf_order = {}
            for nn in range(len(poslist)):
                maf_order[maf_index[nn]] = nn
            branch_list = {}
            num = 0
            for nn in branch_order_sorted:
                if branch_order[nn] in boo_table['count']:
                    for mm in range(boo_table['count'][branch_order[nn]]):
                        branch_list[num] = branch_order[nn]
                        num += 1
            for nn in range(len(poslist)):
                agelist.append(branch_list[maf_order[nn]])
        else:
            error("Unknown outorder method%s" % (mode))
            exit(1)
        try:
            assert len(poslist) == len(agelist)
        except AssertionError:
            error("motif count is not equal to boo count")
            exit(1)
        for nn in range(len(poslist)):
            pos = poslist[nn]
            chrom,start,stop = pos.replace(':','-').split('-')
            print >>out, chrom + '\t' + start + '\t' + stop + '\t' + agelist[nn]

def retrieve_boo_nopos(boo_list,spe,out_filename):
    """retrieve the age of each binding site, main species is spe"""
    out = WriteToFile(out_filename)
    for boo_table in boo_list:
        poslist = boo_table['pos']
        agelist = []
        for branch in boo_table['count'].keys():
            for nn in range(boo_table['count'][branch]):
                agelist.append(branch)
        print >>out, boo_table['pos'][0] + '\t' + ','.join(agelist[nn] for nn in range(len(agelist)))

def clean_TFBS(out_filename, tree, spe):
    '''
    clean result, for controversial TFBS keep the oldest
    '''
    node = tree.get_leaves_by_name(spe)[0]
    num = 0
    branch_order = {}
    while True:
        branch_order[node.name] = num
        if node.is_root(): break
        node = node.up
        num += 1

    def get_oldest(branch_list, branch_order):
        if len(branch_list) == 1:
            return branch_list[0]
        else:
            ancestral = branch_list[0]
            for branch in branch_list[1:]:
                if branch_order[ancestral] < branch_order[branch]:
                    ancestral = branch
            return ancestral 

    os.system("sort -k1,1 -k2,2n %s | uniq >%s" % (out_filename, out_filename+'.sort'))
    fin = ReadFromFile(out_filename+'.sort')
    fout = WriteToFile(out_filename)
    last = None
    for line in fin:
        row = line.strip().split('\t')
        pos = row[0]+'\t'+row[1]+'\t'+row[2]
        branch = row[3]
        if last is None:
            last = [pos, [branch]]
        else:
            if last[0] == pos:
                last[1].append(branch)
            else:
                print >>fout, "%s\t%s" % (last[0], get_oldest(last[1], branch_order))
                last = [pos, [branch]]
    print >>fout, "%s\t%s" % (last[0], get_oldest(last[1], branch_order))
    fin.close()
    fout.close()
    os.unlink(out_filename+'.sort')

###################
# Report parameters
###################

def ReportOptions():
    text = "### TFBS_Evo version numver: beta.20150615\n"
    text += "# Fast level: %d\n" % (args.fast)
    text += "# TFBS count file: %s\n" % (args.count)
    if args.nopos:
        text += "# TFBS count file does not contain TFBS position: True\n"
    text += "# Target species: %s\n" % (args.spe)
    text += "# Phylogenetic Tree: %s\n" % (args.tree)
    text += "# Phylogenetic internal node name: %s\n" % (args.branchname)
    text += "# Branch time calculation method: %s\n" % (args.branchtime)
    text += "# Window size: %d\n" % (args.win)
    text += "# Output File: %s\n" % (args.output)
    text += "# output order of TFBS: %s\n" % (args.outorder)
    if args.assumeyoung:
        text += "# Method to trace back TFBS: Assumeyoung\n"
    else:
        text += "# Method to trace back TFBS: Assumeancient\n"
    if args.outorder == "phyloP":
        text += "# phyloP bigwig file: %s\n" % (args.phyloP)
    print >>sys.stderr, text

#######
# Main
#######

def Main():
    global args
    args=ParseArg()
    ReportOptions()
    start = clock()
    args.eps_raw = 1e-200
    args.eps = log10(args.eps_raw) # resolution
    args.min_prob = -1000000
    tree = LoadTree(args.tree,args.branchname,args.branchtime,ratio=args.branchtime_ratio)
    count_list = LoadCount(args.count,tree)
    count_list_sample = random.sample(count_list,max(int(0.01*len(count_list)),100))
    parameter_list = BOO_converge(count_list_sample,tree,args.spe,alpha_init,beta_init,args.win,10)
    new_alpha = parameter_list['alpha'][-1]
    new_beta = parameter_list['beta'][-1]
    boo_list = BOO(count_list,tree,args.spe,new_alpha,new_beta,args.win,10)
    if args.nopos:
        retrieve_boo_nopos(boo_list, args.spe, args.output)
    else:
        retrieve_boo(boo_list, args.spe, args.output, args.outorder, args.phyloP, args.maf, tree)
    # clean the result
    clean_TFBS(args.output, tree, args.spe)
    stop = clock()
    logging("Finishied! Total running time: " + SecondsToStr(stop-start))
    
if __name__=="__main__":
    Main()
